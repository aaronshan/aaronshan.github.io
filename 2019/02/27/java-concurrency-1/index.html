<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>java并发编程系列-第一篇 - 中龄程序猿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 进程和线程的由来1.1 进程的由来操作系统中为什么会出现进程？ 计算机制造的早期，是用来解决数学问题的，在最初的时候，计算机只能完成特定的指令。用户输入一个指令，计算机就执行一个操作。如果用户在思考或者输入数据的时候，计算机就会等待。很显然，这样的效率很低下，因为大部分情况下，计算机一直都会处于等待输入指令的状态。 后来，就有人想到，能不能把一系列需要执行的指令预先写下来，形成一个清单，一次">
<meta name="keywords" content="java,并发编程,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程系列-第一篇">
<meta property="og:url" content="www.shanruifeng.win/2019/02/27/java-concurrency-1/index.html">
<meta property="og:site_name" content="中龄程序猿">
<meta property="og:description" content="1. 进程和线程的由来1.1 进程的由来操作系统中为什么会出现进程？ 计算机制造的早期，是用来解决数学问题的，在最初的时候，计算机只能完成特定的指令。用户输入一个指令，计算机就执行一个操作。如果用户在思考或者输入数据的时候，计算机就会等待。很显然，这样的效率很低下，因为大部分情况下，计算机一直都会处于等待输入指令的状态。 后来，就有人想到，能不能把一系列需要执行的指令预先写下来，形成一个清单，一次">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.imgur.com/sJvzBO6.jpg?1">
<meta property="og:updated_time" content="2019-02-27T12:48:28.087Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发编程系列-第一篇">
<meta name="twitter:description" content="1. 进程和线程的由来1.1 进程的由来操作系统中为什么会出现进程？ 计算机制造的早期，是用来解决数学问题的，在最初的时候，计算机只能完成特定的指令。用户输入一个指令，计算机就执行一个操作。如果用户在思考或者输入数据的时候，计算机就会等待。很显然，这样的效率很低下，因为大部分情况下，计算机一直都会处于等待输入指令的状态。 后来，就有人想到，能不能把一系列需要执行的指令预先写下来，形成一个清单，一次">
<meta name="twitter:image" content="https://i.imgur.com/sJvzBO6.jpg?1">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="/webfonts/ptserif/main.css" rel="stylesheet" type="text/css">
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <!-- blair add baidu tongji start... @2017.10.03 -->
<!-- blair add baidu tongji end ! @2017.10.03 -->

<header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/love">爱情</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="www.shanruifeng.win"></form>
        </div>
      </nav>
    </div>
  </div>
</header>

    <br>
    <section id="main" class="outer"><article id="post-java-concurrency-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java并发编程系列-第一篇
      <small class="article-detail-date-index">&nbsp; 2019-02-27</small>
    </h1>
  


        <div class="page-title"></div>
        <br>
      </header>
    
    <div class="article-meta">
      <!--<a href="/2019/02/27/java-concurrency-1/" class="article-date">
  <time datetime="2019-02-27T12:41:00.000Z" itemprop="datePublished">2019-02-27</time>
</a>-->
      <!-- 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

--><!-- by blair 160724 -->
      <!-- by blair
      
      -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-进程和线程的由来"><a href="#1-进程和线程的由来" class="headerlink" title="1. 进程和线程的由来"></a>1. 进程和线程的由来</h2><h3 id="1-1-进程的由来"><a href="#1-1-进程的由来" class="headerlink" title="1.1 进程的由来"></a>1.1 进程的由来</h3><p>操作系统中为什么会出现进程？</p>
<p>计算机制造的早期，是用来解决数学问题的，在最初的时候，计算机只能完成特定的指令。用户输入一个指令，计算机就执行一个操作。如果用户在思考或者输入数据的时候，计算机就会等待。很显然，这样的效率很低下，因为大部分情况下，计算机一直都会处于等待输入指令的状态。</p>
<p>后来，就有人想到，能不能把一系列需要执行的指令预先写下来，形成一个清单，一次性交给计算机。计算机呢，则不断的去读取指令来进行相应的操作。(这就是最早的批处理操作系统，用户可以将程序写到磁带上，然后计算机去逐条读取并执行，将结果输出到另一个磁带上。)</p>
<a id="more"></a>
<p>虽然，批处理操作系统能提高任务处理的便捷性，但仍然存在一个很大的问题：</p>
<p>假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能眼睁睁的干等着任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。人们于是想，能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？</p>
<p>但是原来每次都是只有一个程序在计算机里面运行，也就说内存中始终只有这一个程序的运行数据。所以会面临以下问题：</p>
<ol>
<li>如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？</li>
<li>多个程序使用的数据如何进行辨别？</li>
<li>当一个程序运行暂停后，后面如何恢复到它之前执行的状态？</li>
</ol>
<p>为了解决这些问题，就发明了进程。</p>
<ul>
<li>对于问题1，用进程来对应一个程序。</li>
<li>对于问题2，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。</li>
<li>基于上面的设定，对于问题3，由于进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。</li>
</ul>
<p>这就是并发，能够让操作系统从宏观上看起来同一个时间段有多个任务在执行。换句话说，进程让操作系统的并发成为了可能。</p>
<blockquote>
<p>注意，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源（当然是对于单核CPU来说的）。</p>
</blockquote>
<h3 id="1-2-线程的由来"><a href="#1-2-线程的由来" class="headerlink" title="1.2 线程的由来"></a>1.2 线程的由来</h3><p>在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。从上面的内容我们知道一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。</p>
<p>然而对于一个监控系统来说，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取图像数据，还要处理人们的交互操作。如果某一个时刻该系统正在与服务器通信获取图像数据，而用户又在监控系统上点击了某个按钮，那么该系统就要等待获取完图像数据之后才能处理用户的操作，如果获取图像数据需要耗费10s，那么用户就只有一直在等待。显然，对于这样的系统，人们是无法满足的。</p>
<p>那么可不可以将这些子任务分开执行呢？即在系统获取图像数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取图像数据？</p>
<p>于是人们就发明了线程，让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务，这样在用户点击按钮的时候，就可以暂停获取图像数据的线程，让UI线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。</p>
<p><strong>换句话说，进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。</strong></p>
<p>但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</strong></p>
<h3 id="1-3-多线程并发"><a href="#1-3-多线程并发" class="headerlink" title="1.3 多线程并发"></a>1.3 多线程并发</h3><p>由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：<strong>如果多个线程要同时访问某个资源，怎么处理？</strong>这个问题就是后序文章中要重点讲述的同步问题。</p>
<p>现在很多时候都采用多线程编程，那么是不是多线程的性能一定就由于单线程呢？这个问题的答案是：不一定，要看具体的任务以及计算机的配置。</p>
<p>比如说：对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。</p>
<p>但是对于比如交互类型的任务，肯定是需要使用多线程的。</p>
<p>而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。</p>
<p>虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。</p>
<p>为什么多线程是必要的？</p>
<p>个人觉得可以用一句话概括：开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
<p>为什么提倡多线程而不是多进程？</p>
<p>线程就是轻量级进程，是程序执行的最小单位。使用多线程而不是用多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</p>
<h2 id="2-几个重要的概念"><a href="#2-几个重要的概念" class="headerlink" title="2. 几个重要的概念"></a>2. 几个重要的概念</h2><h3 id="2-1-同步和异步"><a href="#2-1-同步和异步" class="headerlink" title="2.1 同步和异步"></a>2.1 同步和异步</h3><p>同步和异步通常用来形容一次方法调用。</p>
<ul>
<li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li>
<li>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。</li>
</ul>
<p>关于异步目前比较经典以及常用的实现方式就是消息队列：在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p>
<h3 id="2-2-并发-Concurrency-和并行-Parallelism"><a href="#2-2-并发-Concurrency-和并行-Parallelism" class="headerlink" title="2.2 并发 (Concurrency) 和并行(Parallelism)"></a>2.2 并发 (Concurrency) 和并行(Parallelism)</h3><p>并发和并行是两个非常容易被混淆的概念。它们都可以表示两个或者多个任务一起执行，但是偏重点有些不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的 “同时执行”。</p>
<p>多线程在单核CPU的话是顺序执行，也就是交替运行（并发）。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行（并行）。</p>
<h3 id="2-3-高并发"><a href="#2-3-高并发" class="headerlink" title="2.3 高并发"></a>2.3 高并发</h3><p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
<p>高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率 QPS（Query Per Second），并发用户数等。</p>
<h3 id="2-4-临界区"><a href="#2-4-临界区" class="headerlink" title="2.4 临界区"></a>2.4 临界区</h3><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。在并行程序中，临界区资源是保护的对象。</p>
<h3 id="2-5-阻塞和非阻塞"><a href="#2-5-阻塞和非阻塞" class="headerlink" title="2.5 阻塞和非阻塞"></a>2.5 阻塞和非阻塞</h3><p>非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回，而阻塞与之相反。</p>
<h2 id="3-使用多线程常见的三种方式"><a href="#3-使用多线程常见的三种方式" class="headerlink" title="3. 使用多线程常见的三种方式"></a>3. 使用多线程常见的三种方式</h2><blockquote>
<p>注：前两种实际上很少使用，一般都是用线程池的方式比较多一点。</p>
</blockquote>
<h3 id="3-1-继承Thread类"><a href="#3-1-继承Thread类" class="headerlink" title="3.1 继承Thread类"></a>3.1 继承Thread类</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"MyThread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Run</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		MyThread mythread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		mythread.start();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"运行结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结束</span><br><span class="line">MyThread</span><br></pre></td></tr></table></figure></p>
<p>从上面的运行结果可以看出：线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run方法。</p>
<h3 id="3-2-实现Runnable接口"><a href="#3-2-实现Runnable接口" class="headerlink" title="3.2 实现Runnable接口"></a>3.2 实现Runnable接口</h3><p>推荐实现Runnable接口方式开发多线程，因为Java单继承但是可以实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"MyRunnable"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Run</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		Runnable runnable=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">		Thread thread=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">		thread.start();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"运行结束！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结束！</span><br><span class="line">MyRunnable</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-使用线程池"><a href="#3-3-使用线程池" class="headerlink" title="3.3 使用线程池"></a>3.3 使用线程池</h3><p>使用线程池的方式也是最推荐的一种方式。</p>
<h2 id="4-实例变量和线程安全"><a href="#4-实例变量和线程安全" class="headerlink" title="4. 实例变量和线程安全"></a>4. 实例变量和线程安全</h2><p>线程类中的实例变量针对其他线程可以有共享和不共享之分。下面通过两个简单的例子来说明！</p>
<h3 id="4-1-不共享数据的情况"><a href="#4-1-不共享数据的情况" class="headerlink" title="4.1 不共享数据的情况"></a>4.1 不共享数据的情况</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个线程之间不共享变量线程安全的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> MyThread(String name) &#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.setName(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">count</span>--;</span><br><span class="line">			System.out.println(<span class="string">"由"</span> + MyThread.currentThread().getName() + <span class="string">"计算，count="</span> + <span class="keyword">count</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">		MyThread a = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">		MyThread b = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">		MyThread c = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">由C计算，<span class="attribute">count</span>=4</span><br><span class="line">由C计算，<span class="attribute">count</span>=3</span><br><span class="line">由C计算，<span class="attribute">count</span>=2</span><br><span class="line">由C计算，<span class="attribute">count</span>=1</span><br><span class="line">由C计算，<span class="attribute">count</span>=0</span><br><span class="line">由A计算，<span class="attribute">count</span>=4</span><br><span class="line">由B计算，<span class="attribute">count</span>=4</span><br><span class="line">由B计算，<span class="attribute">count</span>=3</span><br><span class="line">由B计算，<span class="attribute">count</span>=2</span><br><span class="line">由A计算，<span class="attribute">count</span>=3</span><br><span class="line">由A计算，<span class="attribute">count</span>=2</span><br><span class="line">由B计算，<span class="attribute">count</span>=1</span><br><span class="line">由B计算，<span class="attribute">count</span>=0</span><br><span class="line">由A计算，<span class="attribute">count</span>=1</span><br><span class="line">由A计算，<span class="attribute">count</span>=0</span><br></pre></td></tr></table></figure></p>
<p>可以看出每个线程都有一个属于自己的实例变量 count，它们之间互不影响。我们再来看看另一种情况。</p>
<h3 id="4-2-共享数据的情况"><a href="#4-2-共享数据的情况" class="headerlink" title="4.2 共享数据的情况"></a>4.2 共享数据的情况</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个线程之间共享变量线程不安全的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedVariableThread</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Thread</span></span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> int count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> void run() &#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(<span class="string">"由"</span> + SharedVariableThread.currentThread().getName() + <span class="string">"计算，count="</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">		SharedVariableThread mythread = <span class="keyword">new</span> <span class="type">SharedVariableThread</span>();</span><br><span class="line">		<span class="comment">// 下列线程都是通过mythread对象创建的</span></span><br><span class="line">		Thread a = <span class="keyword">new</span> <span class="type">Thread</span>(mythread, <span class="string">"A"</span>);</span><br><span class="line">		Thread b = <span class="keyword">new</span> <span class="type">Thread</span>(mythread, <span class="string">"B"</span>);</span><br><span class="line">		Thread c = <span class="keyword">new</span> <span class="type">Thread</span>(mythread, <span class="string">"C"</span>);</span><br><span class="line">		Thread d = <span class="keyword">new</span> <span class="type">Thread</span>(mythread, <span class="string">"D"</span>);</span><br><span class="line">		Thread e = <span class="keyword">new</span> <span class="type">Thread</span>(mythread, <span class="string">"E"</span>);</span><br><span class="line">		a.start();</span><br><span class="line">		b.start();</span><br><span class="line">		c.start();</span><br><span class="line">		d.start();</span><br><span class="line">		e.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由A计算，<span class="attribute">count</span>=4</span><br><span class="line">由D计算，<span class="attribute">count</span>=0</span><br><span class="line">由E计算，<span class="attribute">count</span>=1</span><br><span class="line">由B计算，<span class="attribute">count</span>=2</span><br><span class="line">由C计算，<span class="attribute">count</span>=2</span><br></pre></td></tr></table></figure>
<p>可以看出这里已经出现了错误，我们想要的是依次递减的结果。为什么呢？？</p>
<p>因为在大多数 jvm 中，count–的操作分为如下下三步：</p>
<ol>
<li>取得原有 count 值</li>
<li>计算 i -1</li>
<li>对 i 进行赋值</li>
</ol>
<p>所以多个线程同时访问时出现问题就是难以避免的了。</p>
<p>那么有没有什么解决办法呢？</p>
<blockquote>
<p>答案是：当然有，而且很简单。给大家提供两种解决办法：</p>
<ol>
<li>synchronized关键字（保证任意时刻只能有一个线程执行该方法）</li>
<li>利用 AtomicInteger 类（JUC 中的 Atomic 原子类）。</li>
</ol>
<p>注意：这里不能用volatile关键字，因为volatile关键字不能保证复合操作的原子性。</p>
</blockquote>
<h2 id="5-一些常用方法"><a href="#5-一些常用方法" class="headerlink" title="5. 一些常用方法"></a>5. 一些常用方法</h2><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">currentThread()</td>
<td style="text-align:left">返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td style="text-align:left">getId()</td>
<td style="text-align:left">返回此线程的标识符</td>
</tr>
<tr>
<td style="text-align:left">setName(String name)</td>
<td style="text-align:left">将此线程的名称更改为等于参数name</td>
</tr>
<tr>
<td style="text-align:left">getName()</td>
<td style="text-align:left">返回此线程的名称</td>
</tr>
<tr>
<td style="text-align:left">setPriority(int newPriority)</td>
<td style="text-align:left">更改此线程的优先级</td>
</tr>
<tr>
<td style="text-align:left">getPriority()</td>
<td style="text-align:left">返回此线程的优先级</td>
</tr>
<tr>
<td style="text-align:left">setDaemon(boolean on)</td>
<td style="text-align:left">将此线程标记为 daemon 线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">isDaemon()</td>
<td style="text-align:left">测试这个线程是否是守护线程。</td>
</tr>
<tr>
<td style="text-align:left">isAlive()</td>
<td style="text-align:left">测试这个线程是否还处于活动状态(活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。)。</td>
</tr>
<tr>
<td style="text-align:left">sleep(long millis)</td>
<td style="text-align:left">使当前正在执行的线程以指定的毫秒数 “休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</td>
</tr>
<tr>
<td style="text-align:left">interrupt()</td>
<td style="text-align:left">中断这个线程。</td>
</tr>
<tr>
<td style="text-align:left">interrupted()</td>
<td style="text-align:left">测试当前线程是否已经是中断状态，执行后具有将状态标志清除为 false 的功能</td>
</tr>
<tr>
<td style="text-align:left">isInterrupted()</td>
<td style="text-align:left">测试线程 Thread 对相关是否已经是中断状态，但部清楚状态标志</td>
</tr>
<tr>
<td style="text-align:left">join()</td>
<td style="text-align:left">在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。join() 的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行</td>
</tr>
<tr>
<td style="text-align:left">yield()</td>
<td style="text-align:left">yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用 CPU 时间。注意：放弃的时间不确定，可能一会就会重新获得 CPU 时间片。</td>
</tr>
</tbody>
</table>
<h2 id="6-如何停止一个线程"><a href="#6-如何停止一个线程" class="headerlink" title="6. 如何停止一个线程"></a>6. 如何停止一个线程</h2><blockquote>
<p>stop(),suspend(),resume()（仅用于与 suspend() 一起使用）这些方法已被弃用，所以此处不予讲解。</p>
</blockquote>
<p><img src="https://i.imgur.com/sJvzBO6.jpg?1" alt></p>
<h3 id="6-1-使用-interrupt-方法"><a href="#6-1-使用-interrupt-方法" class="headerlink" title="6.1 使用 interrupt() 方法"></a>6.1 使用 interrupt() 方法</h3><p>我们上面提到了interrupt() 方法，先来试一下 interrupt() 方法能不能停止线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">			thread.start();</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			thread.interrupt();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"main catch"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码你会发现，线程并不会终止。</p>
<p>针对上面代码的一个改进：</p>
<p>interrupted() 方法判断线程是否停止，如果是停止状态则 break</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterruptThread2</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.interrupted()) &#123;</span><br><span class="line">				System.<span class="keyword">out</span>.println(<span class="string">"已经是停止状态了!我要退出了!"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"i="</span> + (i + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"看到这句话说明线程并未终止------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InterruptThread2 thread = <span class="keyword">new</span> InterruptThread2();</span><br><span class="line">			thread.start();</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">			thread.interrupt();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"main catch"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=344061</span><br><span class="line">i=344062</span><br><span class="line">i=344063</span><br><span class="line">已经是停止状态了!我要退出了!</span><br><span class="line">看到这句话说明线程并未终止------</span><br></pre></td></tr></table></figure></p>
<p>for 循环虽然停止执行了，但是 for 循环下面的语句还是会执行，说明线程并未被停止。</p>
<h3 id="6-2-使用-return-停止线程"><a href="#6-2-使用-return-停止线程" class="headerlink" title="6.2 使用 return 停止线程"></a>6.2 使用 return 停止线程</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void run() &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">					<span class="type">System</span>.out.println(<span class="string">"停止了!"</span>);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">System</span>.out.println(<span class="string">"timer="</span> + <span class="type">System</span>.currentTimeMillis());</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> t=<span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">		t.start();</span><br><span class="line">		<span class="type">Thread</span>.sleep(<span class="number">2000</span>);</span><br><span class="line">		t.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line"><span class="section">timer</span>=<span class="number">1551270875684</span></span><br><span class="line">停止了!</span><br></pre></td></tr></table></figure>
<p>当然还有其他停止线程的方法，后面再做介绍。</p>
<h2 id="7-线程的优先级"><a href="#7-线程的优先级" class="headerlink" title="7. 线程的优先级"></a>7. 线程的优先级</h2><p>每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这个并不意味着低<br>优先级的线程得不到运行，而只是它运行的几率比较小，如垃圾回收机制线程的优先级就比较低。所以很多垃圾得不到及时的回收处理。</p>
<p>线程优先级具有继承特性，比如A线程启动B线程，则B线程的优先级和A是一样的。</p>
<p>线程优先级具有随机性，也就是说线程优先级高的不一定每一次都先执行完。</p>
<p>Thread 类中包含的成员变量代表了线程的某些优先级。如 Thread.MIN_PRIORITY（常数 1），Thread.NORM_PRIORITY（常数 5）,<br>Thread.MAX_PRIORITY（常数 10）。</p>
<p>其中每个线程的优先级都在 Thread.MIN_PRIORITY（常数 1） 到 Thread.MAX_PRIORITY（常数 10） 之间，在默认情况下优先级都是 Thread.NORM_PRIORITY（常数 5）。</p>
<p>学过操作系统这门课程的话，我们可以发现多线程优先级或多或少借鉴了操作系统对进程的管理。</p>
<p>线程优先级具有继承特性测试代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"MyThread1 run priority="</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">		<span class="type">MyThread2</span> thread2 = <span class="keyword">new</span> <span class="type">MyThread2</span>();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"MyThread2 run priority="</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Run</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"main thread begin priority="</span> + Thread.currentThread().getPriority());</span><br><span class="line">		Thread.currentThread().setPriority(<span class="number">6</span>);</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"main thread end   priority="</span> + Thread.currentThread().getPriority());</span><br><span class="line">		MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">		thread1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main thread begin <span class="attribute">priority</span>=5</span><br><span class="line">main thread end   <span class="attribute">priority</span>=6</span><br><span class="line">MyThread1 <span class="builtin-name">run</span> <span class="attribute">priority</span>=6</span><br><span class="line">MyThread2 <span class="builtin-name">run</span> <span class="attribute">priority</span>=6</span><br></pre></td></tr></table></figure></p>
<h2 id="8-Java多线程分类"><a href="#8-Java多线程分类" class="headerlink" title="8. Java多线程分类"></a>8. Java多线程分类</h2><h3 id="8-1-多线程分类"><a href="#8-1-多线程分类" class="headerlink" title="8.1 多线程分类"></a>8.1 多线程分类</h3><ul>
<li>用户线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li>
<li><p>守护线程：运行在后台，为其他前台线程服务. 也可以说守护线程是JVM中非守护线程的 “佣人”。</p>
</li>
<li><p>特点：一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</p>
</li>
<li>应用：数据库连接池中的检测线程，JVM 虚拟机启动后的检测线程</li>
</ul>
<p>最常见的守护线程：垃圾回收线程</p>
<h3 id="8-2-如何设置守护线程？"><a href="#8-2-如何设置守护线程？" class="headerlink" title="8.2 如何设置守护线程？"></a>8.2 如何设置守护线程？</h3><p>可以通过调用Thead类的setDaemon(true)方法设置当前的线程为守护线程</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>setDaemon(true)必须在start（）方法前执行，否则会抛出IllegalThreadStateException异常</li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>
</ol>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> int i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void run() &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="type">System</span>.out.println(<span class="string">"i="</span> + (i));</span><br><span class="line">				<span class="type">Thread</span>.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Run</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">			thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">			thread.start();</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			System.<span class="keyword">out</span>.println(<span class="string">"我离开thread对象也不再打印了，也就是停止了！"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i=43</span><br><span class="line">i=44</span><br><span class="line">i=45</span><br><span class="line">i=46</span><br><span class="line">i=47</span><br><span class="line">i=48</span><br><span class="line">i=49</span><br><span class="line">我离开thread对象也不再打印了，也就是停止了！</span><br></pre></td></tr></table></figure></p>

      
     <!-- by blair add this if sentence at 20160725 -->
      <br>
      
<div id="bottom-donation-section">
<span style="font-size: 1.0em; padding:0em 1em 0.5em 1em; margin: 0 auto;">
  <strong style="vertical-align: top;">分享到:</strong>
    <div class="j_handlclick" style="background: url(https://i.imgur.com/O2KwD6W.png);background-size: contain;display: inline-block; width:50px; height:50px" href="https://www.facebook.com/sharer/sharer.php?u=" target="_blank">
    </div>
    <div class="j_handlclick" style="background: url(https://i.imgur.com/7mGVpga.png);background-size: contain;display: inline-block; width:50px; height:50px" href="https://service.weibo.com/share/share.php?url" target="_blank">
    </div>
    <div class="j_handlclick" style="background: url(https://i.imgur.com/2jR6Gdk.png);background-size: contain;display: inline-block; width:50px; height:50px" href="https://api.addthis.com/oexchange/0.8/forward/wechat/offer?url=" target="_blank">
    </div>
    <div class="j_handlclick" style="background: url(https://i.imgur.com/0LNj3xG.png);background-size: contain;display: inline-block; width:50px; height:50px" href="https://twitter.com/intent/tweet?url=" target="_blank">
    </div>
  <br>  
  <br>  
  &nbsp;&nbsp;如果您觉得这篇文章对您的学习很有帮助, 请您也分享它, 让它能再次帮助到更多的需要学习的人.
您的<a href="/support/"><strong>支持</strong></a>将鼓励我继续创作 !
  <br>  

</span>
<!--
<h3 id="bottom-donation-title">支持 让文章变得更优质</h3>
<div>
<a id="bottom-donation-button" href="/support">点我 赞助 作者</a>
</div>
-->
</div>
<div class="well">
  <!--
  原创文章，转载请注明： 转载自<a href="https://www.shanruifeng.win"> 中龄程序猿</a>，作者：
  <a href="/about">aaronshan</a> <br>
  -->
  本文基于<a target="_blank" title="Creative Commons Attribution 4.0 international License" href="https://creativecommons.org/licenses/by-nc/4.0/">署名4.0国际许可协议</a>发布，转载请保留本文署名和文章链接。 如您有任何授权方面的协商，请邮件联系我。
</div>
 <!-- by blair add 160724-->
    
    </div>
    
      <div class="article-toc">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-进程和线程的由来"><span class="toc-number">1.</span> <span class="toc-text">1. 进程和线程的由来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-进程的由来"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 进程的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-线程的由来"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 线程的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-多线程并发"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 多线程并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-几个重要的概念"><span class="toc-number">2.</span> <span class="toc-text">2. 几个重要的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-同步和异步"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-并发-Concurrency-和并行-Parallelism"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 并发 (Concurrency) 和并行(Parallelism)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-高并发"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 高并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-临界区"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-阻塞和非阻塞"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 阻塞和非阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-使用多线程常见的三种方式"><span class="toc-number">3.</span> <span class="toc-text">3. 使用多线程常见的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-继承Thread类"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 继承Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-实现Runnable接口"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-使用线程池"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 使用线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-实例变量和线程安全"><span class="toc-number">4.</span> <span class="toc-text">4. 实例变量和线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-不共享数据的情况"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 不共享数据的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-共享数据的情况"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 共享数据的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-一些常用方法"><span class="toc-number">5.</span> <span class="toc-text">5. 一些常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-如何停止一个线程"><span class="toc-number">6.</span> <span class="toc-text">6. 如何停止一个线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-使用-interrupt-方法"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 使用 interrupt() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-使用-return-停止线程"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 使用 return 停止线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-线程的优先级"><span class="toc-number">7.</span> <span class="toc-text">7. 线程的优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Java多线程分类"><span class="toc-number">8.</span> <span class="toc-text">8. Java多线程分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-多线程分类"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 多线程分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-如何设置守护线程？"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 如何设置守护线程？</span></a></li></ol></li></ol>
      </div>
    
    
      <footer class="article-footer">
        <!-- <div class="well" style="width:100px; height:30px;"></div>  by blair-->
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

 <!-- by blair add 160724-->
        <!--
        <div style="width:100px; height:30px;"></div> by blair add 160724
        -->
        
  <div class="article-tag">
    <a class="article-tag-link" href="/tags/java/">java</a><span></span><a class="article-tag-link" href="/tags/多线程/">多线程</a><span></span><a class="article-tag-link" href="/tags/并发编程/">并发编程</a>
  </div>


      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/01/gc-roots-obj/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          可以作为GC Roots的对象
        
      </div>
    </a>
  
  
    <a href="/2017/04/19/aprf1/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">机器学习评价标准&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 aaronshan&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/52binge/hexo-theme-blairos">blairos</a>
    </div>
  </div>
</footer>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX"],
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(','\\)'] ],
      displayMath: [ ['$$','$$']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML,http://myserver.com/MathJax/config/local/local.js">
</script>

    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
